# This is a basic workflow to help you get started with Actions

name: Integration Test on Azure DevTest Labs 

# Controls when the action will run. 
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  push:
    branches:
    - feature/azure-devtest-labs-arm-CICD
  #pull_request:
  #  branches: [ main ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build-and-integration-test:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Variables for creating the leb environment
    env:
      RESOURCE_GROUP: AzureDataPipelineTools_CI
      LAB_NAME: AzureDataPipelineTools
      ARM_TEMPLATE_NAME: sqlcollaborative_AzureDataPipelineTools
      FUNCTIONS_PROJECT_NAME: DataPipelineTools.Functions
      BUILD_CONFIGURATION: Release
      RUN_SETTINGS_FILENAME: ./integrationTest.runsettings


    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
    - uses: actions/checkout@v2


    # Build and run the unit tests
    - name: Setup .NET
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore --configuration ${{ env.BUILD_CONFIGURATION }} --output ./output


    - name: List Build Files 
      run: |
        ls -ltAR ./${{ env.FUNCTIONS_PROJECT_NAME }}/bin/${{ env.BUILD_CONFIGURATION }}

    - name: Run Unit Tests
      run: dotnet test --no-build --configuration ${{ env.BUILD_CONFIGURATION }} --filter TestCategory=UnitTest --output ./output --verbosity normal

    # - name: Extract 
    #   run: |
    #     echo "Retriving service principal client secret for the logged in user..."
    #     echo $("${{ secrets.AZURE_DEV_TEST_LABS_CREDENTIALS }}" | jq '.clientId')



    # Login to Azure
    - name: Log into Azure
      uses: azure/login@v1
      with:
        creds: '${{ secrets.AZURE_DEV_TEST_LABS_CREDENTIALS }}'



    # --raw-output is requiored on all jq commands that select strings, otherwise they come out with the quotes, which is interpreted as a command, and it likely won't exist!
    - name: Create DevTest Labs Environment
      id: create-devtest-labs-environment
      uses: azure/CLI@v1
      with:
        # azcliversion: 2.24.0  # Versions prior to this have a bug creating environments
        # This runs in a container, so all output is passed back using 'echo "::set-output name=OUTPUT_VAR_NAME::value here"', as files created won't persist.
        inlineScript: |
          echo "========================================================================================================================================================================================================"
          echo "Azure CLI Version: $(az version |  jq '."azure-cli"')"
          echo
          echo "Connection info:"
          az account show | jq '. | {tenantId: .tenantId, subscriptionName: .name, userName: .user.name, userType: .user.type}'
          echo
          
          echo "Configuring variables for secrets:"
          # We need the secrets in a variable so we can work with them using normal shell script syntax. The '${ {  VAR } }' syntax is token replaced before the script runs.
          SERVICEPRINCIPALCREDENTIALS=$'${{ secrets.AZURE_DEV_TEST_LABS_CREDENTIALS }}'
          echo "========================================================================================================================================================================================================"
          echo

          ARTIFACT_SOURCE_NAME=$(az lab artifact-source list --resource-group $RESOURCE_GROUP \
                                                             --lab-name $LAB_NAME \
                                     | jq --raw-output \
                                          '.[] | select( .uri == "https://github.com/sqlcollaborative/AzureDataPipelineTools.git" ) | .name' \
                                )

          echo "Artifact Source Name: $ARTIFACT_SOURCE_NAME"

          BRANCH_NAME=${GITHUB_REF#*refs/heads/}
          echo "Branch Name: $BRANCH_NAME"

          # We need the object id of the Enterprise Application created from the App Registration in order to set permissions in the ARM template. This is **not** the same as the app/client id
          echo "Retriving service principal id for the logged in user..."
          SERVICEPRINCIPALAPPID=$(az account show | jq --raw-output '.user.name')
          echo "Service Principal App/Client Id: $SERVICEPRINCIPALAPPID"
          SERVICEPRINCIPALID=$( az ad sp list --filter "appId eq '$SERVICEPRINCIPALAPPID' and servicePrincipalType eq 'Application'" --query [0].objectId --output tsv)
          echo "Service Principal Object Id:     $SERVICEPRINCIPALID"

          echo "Building parameters file for ARM deployment..."
          PARAMETERS_FILE="$(pwd)/azuredeploy.parameters.json"
          echo $'[ { "name":"'branch'", "value":"'$BRANCH_NAME'" },' \
                '  { "name":"'commit'", "value":"'$GITHUB_SHA'" },' \
                '  { "name":"'location'", "value":"UK South" },' \
                '  { "name":"'devopsServicePrincipalId'", "value":"'$SERVICEPRINCIPALID'" },' \
                '  { "name":"'devopsServicePrincipalCredentials'", "value":' $SERVICEPRINCIPALCREDENTIALS ' }' \
                ']' \
            | jq '.' > "$PARAMETERS_FILE"
          #cat $PARAMETERS_FILE

          ENVIRONMENT_INSTANCE_NAME='CI_Build___'"${BRANCH_NAME////__}"'___'"${GITHUB_SHA:0:8}"''
          echo "Environment Instance Name: $ENVIRONMENT_INSTANCE_NAME"
          
          echo "::set-output name=ENVIRONMENT_INSTANCE_NAME::$ENVIRONMENT_INSTANCE_NAME"

          ENVIRONMENT_CREATE_OUTPUT=$(az lab environment create --resource-group $RESOURCE_GROUP \
                                                                --lab-name $LAB_NAME \
                                                                --name $ENVIRONMENT_INSTANCE_NAME \
                                                                --artifact-source-name $ARTIFACT_SOURCE_NAME \
                                                                --arm-template $ARM_TEMPLATE_NAME \
                                                                --parameter "@$PARAMETERS_FILE" \
                                                                --verbose \
                                         | jq '.'
                                     )

          echo "Output from 'az lab environment create'"
          echo $ENVIRONMENT_CREATE_OUTPUT

          PROVISIONING_STATE=$(echo $ENVIRONMENT_CREATE_OUTPUT |  jq --raw-output '.provisioningState')
          echo "Provisioning State: $PROVISIONING_STATE"

          ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME=$(echo $ENVIRONMENT_CREATE_OUTPUT |  jq --raw-output '.resourceGroupId' | xargs basename)
          echo "Resource Group Id: $ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME"
          
          echo "::set-output name=ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME::$ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME"

          if [ $PROVISIONING_STATE != "Succeeded" ]; then
            echo "::error Error provisioning lab environment"
            exit 1
          fi

          echo "========================================================================================================================================================================================================"
          DEPLOYMENTOUTPUT=$(az deployment group list --resource-group $ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME --query '[0].properties.outputs')

          # DEBUG: Use this to get the full deployment output JSON. If the ARM template outputs a full reference to a resource, we can find the bits we need easily.
          # echo "::set-output name=DEPLOYMENTOUTPUT::$DEPLOYMENTOUTPUT"
          
          echo "Deployment Outputs"
          #echo "::set-output name=STORAGE_ACCOUNTCONNECTION_STRING::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.storageAccountConnectionString.value')"
          echo "::set-output name=STORAGE_ACCOUNT_NAME::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.storageAccountName.value')"
          echo "::set-output name=FUNCTIONS_APP_NAME::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.functionsAppName.value')"
          echo "::set-output name=FUNCTIONS_APP_URI::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.functionsAppUri.value')"
          echo "::set-output name=KEY_VAULT_NAME::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.keyVaultName.value')"
          #echo "::set-output name=FUNCTIONS_APP_KEY::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.functionsAppKey.value')"
          echo "::set-output name=RUN_SETTINGS::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.runSettings.value')"

          echo "========================================================================================================================================================================================================"
    
    
    
    # Runs a set of commands using the runners shell
    - name: Show create environment outputs
      run: |
        #echo "ENVIRONMENT_INSTANCE_NAME:                ${{ steps.create-devtest-labs-environment.outputs.ENVIRONMENT_INSTANCE_NAME }}"
        #echo "ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME: ${{ steps.create-devtest-labs-environment.outputs.ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME }}"
        echo "FUNCTIONS_APP_NAME:                       ${{ steps.create-devtest-labs-environment.outputs.FUNCTIONS_APP_NAME }}"
        echo "FUNCTIONS_APP_URI:                        ${{ steps.create-devtest-labs-environment.outputs.FUNCTIONS_APP_URI }}"
        #echo "FUNCTIONS_APP_KEY:                        ${{ steps.create-devtest-labs-environment.outputs.FUNCTIONS_APP_KEY }}"
        #echo "STORAGE_ACCOUNTCONNECTION_STRING:         ${{ steps.create-devtest-labs-environment.outputs.STORAGE_ACCOUNTCONNECTION_STRING }}"
        echo "STORAGE_ACCOUNT_NAME:                     ${{ steps.create-devtest-labs-environment.outputs.STORAGE_ACCOUNT_NAME }}"
        echo "KEY_VAULT_NAME:                           ${{ steps.create-devtest-labs-environment.outputs.KEY_VAULT_NAME }}"
        echo 'RUN_SETTINGS:                             ${{ steps.create-devtest-labs-environment.outputs.RUN_SETTINGS }}'
    
    
    # Write the runsettings output from the ARM script into a file so that the integration tests can use it
    - name: Write the DevTest Labs output runsettings to file
      run: |    
        echo '${{ steps.create-devtest-labs-environment.outputs.RUN_SETTINGS }}' > ${{ env.RUN_SETTINGS_FILENAME }}
# echo "ENVIRONMENT_INSTANCE_RESOURCES: ${{ steps.get-devtest-labs-environment-resources.outputs.ENVIRONMENT_INSTANCE_RESOURCES }}"
# az lab arm-template show --resource-group $RESOURCE_GROUP






    # - name: Get DevTest Labs Environment Resource Info
    #   id: get-devtest-labs-environment-resources
    #   uses: azure/CLI@v1
    #   with:
    #     #azcliversion: 2.24.0  # Versions prior to this have a bug creating environments
    #     inlineScript: |
    #       echo "========================================================================================================================================================================================================"
    #       echo "Azure CLI Version: $(az version |  jq '."azure-cli"')"
    #       echo
    #       echo "Connection info:"
    #       az account show | jq '. | {tenantId: .tenantId, subscriptionName: .name, userName: .user.name, userType: .user.type}'
    #       echo

    #       RESOURCE_GROUP="${{ steps.create-devtest-labs-environment.outputs.ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME }}"

    #       ENVIRONMENT_INSTANCE_RESOURCES=$(az resource list --resource-group $RESOURCE_GROUP \
    #                                         | jq '.[] | { name: .name, id: .id, provisioningState: .provisioningState, kind: .kind, location: .location, tags: .tags }'
    #                                       )

    #       echo "Output from 'az resource list --resource-group $RESOURCE_GROUP'"
    #       echo
    #       echo $ENVIRONMENT_INSTANCE_RESOURCES

    #       echo "::set-output name=ENVIRONMENT_INSTANCE_RESOURCES::$ENVIRONMENT_INSTANCE_RESOURCES"

    #       echo "========================================================================================================================================================================================================"

   
   # Install AZCopy and copy sample files into the data lake
    - name: Install azcopy
      uses: kheiakiyama/install-azcopy-action@v1.0.3
      with:
        version: 'v10'

    - name: Copy files to Azure Data Lake using AZCopy
      run: |
        ls -ltA
#azcopy_v10 --source {SOURCE} --destination {DEST} --dest-key ${{ secrets.STORAGE_KEY }} --recursive --set-content-type
    
    - name: 'Deploy Azure Functions to Lab Environment using RBAC'
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ steps.create-devtest-labs-environment.outputs.FUNCTIONS_APP_NAME }}
        package: './${{ env.FUNCTIONS_PROJECT_NAME }}/bin/${{ env.BUILD_CONFIGURATION }}'


    - name: Run Integration Tests
      run: dotnet test --no-build --configuration ${{ env.BUILD_CONFIGURATION }} --filter TestCategory=IntegrationTest --output ./output --verbosity normal --settings ${{ env.RUN_SETTINGS_FILENAME }}



    
