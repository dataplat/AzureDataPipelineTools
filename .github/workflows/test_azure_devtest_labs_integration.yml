# This is a basic workflow to help you get started with Actions

name: Integration Test on Azure DevTest Labs 

# Controls when the action will run. 
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  push:
    branches:
    - feature/azure-devtest-labs-arm-CICD
  #pull_request:
  #  branches: [ main ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build-and-integration-test:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Variables for creating the leb environment
    env:
      RESOURCE_GROUP: AzureDataPipelineTools_CI
      LAB_NAME: AzureDataPipelineTools
      ARM_TEMPLATE_NAME: sqlcollaborative_AzureDataPipelineTools
      FUNCTIONS_PROJECT_NAME: DataPipelineTools.Functions
      BUILD_CONFIGURATION: Release
      RUN_SETTINGS_FILENAME: ./integrationTest.runsettings


    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
    - uses: actions/checkout@v2


    # Build and run the unit tests
    - name: Setup .NET
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore --configuration ${{ env.BUILD_CONFIGURATION }} --output ./output


    # - name: List Build Files 
    #   run: |
    #     ls -ltAR ./${{ env.FUNCTIONS_PROJECT_NAME }}/bin/${{ env.BUILD_CONFIGURATION }}

    - name: Run Unit Tests
      run: dotnet test --no-build --configuration ${{ env.BUILD_CONFIGURATION }} --filter TestCategory=UnitTest --output ./output --verbosity normal


    # Login to Azure
    - name: Log into Azure
      uses: azure/login@v1
      with:
        creds: '${{ secrets.AZURE_DEV_TEST_LABS_CREDENTIALS }}'



    # --raw-output is requiored on all jq commands that select strings, otherwise they come out with the quotes, which is interpreted as a command, and it likely won't exist!
    - name: Create DevTest Labs Environment
      id: create-devtest-labs-environment
      uses: azure/CLI@v1
      with:
        # azcliversion: 2.24.0  # Versions prior to this have a bug creating environments
        # This runs in a container, so all output is passed back using 'echo "::set-output name=OUTPUT_VAR_NAME::value here"', as files created won't persist.
        inlineScript: |
          echo "========================================================================================================================================================================================================"
          echo "Azure CLI Version: $(az version |  jq '."azure-cli"')"
          echo
          echo "Connection info:"
          az account show | jq '. | {tenantId: .tenantId, subscriptionName: .name, userName: .user.name, userType: .user.type}'
          echo
          
          echo "Configuring variables for secrets:"
          # We need the secrets in a variable so we can work with them using normal shell script syntax. The '${ {  VAR } }' syntax is token replaced before the script runs.
          SERVICEPRINCIPALCREDENTIALS=$'${{ secrets.AZURE_DEV_TEST_LABS_CREDENTIALS }}'
          echo "========================================================================================================================================================================================================"
          echo

          ARTIFACT_SOURCE_NAME=$(az lab artifact-source list --resource-group $RESOURCE_GROUP \
                                                             --lab-name $LAB_NAME \
                                     | jq --raw-output \
                                          '.[] | select( .uri == "https://github.com/sqlcollaborative/AzureDataPipelineTools.git" ) | .name' \
                                )

          echo "Artifact Source Name: $ARTIFACT_SOURCE_NAME"

          BRANCH_NAME=${GITHUB_REF#*refs/heads/}
          echo "Branch Name: $BRANCH_NAME"

          # We need the object id of the Enterprise Application created from the App Registration in order to set permissions in the ARM template. This is **not** the same as the app/client id
          echo "Retriving service principal id for the logged in user..."
          SERVICEPRINCIPALAPPID=$(az account show | jq --raw-output '.user.name')
          echo "Service Principal App/Client Id: $SERVICEPRINCIPALAPPID"
          SERVICEPRINCIPALID=$( az ad sp list --filter "appId eq '$SERVICEPRINCIPALAPPID' and servicePrincipalType eq 'Application'" --query [0].objectId --output tsv)
          echo "Service Principal Object Id:     $SERVICEPRINCIPALID"

          
          # Build a JSON snippet with the client/app id, object id and client secret for the devops SPN. This is used by the ARM template to grant permissions on resources so that the devops SPN
          # can deploy code into them. The ARM template generates the required .runsettings file for the integration tests as an output, which reuses the devops SPN to access resources to test.
          SERVICEPRINCIPALINFO=$( echo $SERVICEPRINCIPALCREDENTIALS | jq '{clientId, clientSecret, $clientObjectId}' --arg 'clientObjectId' $SERVICEPRINCIPALID -c )
          
          echo "Service Principal Info:          $SERVICEPRINCIPALINFO"

          echo "Building parameters file for ARM deployment..."
          PARAMETERS_FILE="$(pwd)/azuredeploy.parameters.json"
          echo $'[ { "name":"branch", "value":"'$BRANCH_NAME'" },' \
                '  { "name":"commit", "value":"'$GITHUB_SHA'" },' \
                '  { "name":"location", "value":"UK South" },' \
                '  { "name":"devopsServicePrincipalId", "value":"'$SERVICEPRINCIPALID'" },' \
                '  { "name":"devopsServicePrincipalCredentials", "value":' $SERVICEPRINCIPALCREDENTIALS ' },' \
                '  { "name":"devopsServicePrincipalCredentialsTest", "value":' $SERVICEPRINCIPALINFO ' }' \
                ']' \
            | jq '.' > "$PARAMETERS_FILE"
          #cat $PARAMETERS_FILE

          ENVIRONMENT_INSTANCE_NAME='CI_Build___'"${BRANCH_NAME////__}"'___'"${GITHUB_SHA:0:8}"''
          echo "Environment Instance Name: $ENVIRONMENT_INSTANCE_NAME"
          
          echo "::set-output name=ENVIRONMENT_INSTANCE_NAME::$ENVIRONMENT_INSTANCE_NAME"

          ENVIRONMENT_CREATE_OUTPUT=$(az lab environment create --resource-group $RESOURCE_GROUP \
                                                                --lab-name $LAB_NAME \
                                                                --name $ENVIRONMENT_INSTANCE_NAME \
                                                                --artifact-source-name $ARTIFACT_SOURCE_NAME \
                                                                --arm-template $ARM_TEMPLATE_NAME \
                                                                --parameter "@$PARAMETERS_FILE" \
                                                                --verbose \
                                         | jq '.'
                                     )

          echo "Output from 'az lab environment create'"
          echo $ENVIRONMENT_CREATE_OUTPUT

          PROVISIONING_STATE=$(echo $ENVIRONMENT_CREATE_OUTPUT |  jq --raw-output '.provisioningState')
          echo "Provisioning State: $PROVISIONING_STATE"

          ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME=$(echo $ENVIRONMENT_CREATE_OUTPUT |  jq --raw-output '.resourceGroupId' | xargs basename)
          echo "Resource Group Id: $ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME"
          
          echo "::set-output name=ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME::$ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME"

          if [ $PROVISIONING_STATE != "Succeeded" ]; then
            echo "::error Error provisioning lab environment"
            exit 1
          fi

          echo "========================================================================================================================================================================================================"
          DEPLOYMENTOUTPUT=$(az deployment group list --resource-group $ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME --query '[0].properties.outputs')

          # DEBUG: Use this to get the full deployment output JSON. If the ARM template outputs a full reference to a resource, we can find the bits we need easily.
          # echo "::set-output name=DEPLOYMENTOUTPUT::$DEPLOYMENTOUTPUT"
          
          echo "Deployment Outputs"
          #echo "::set-output name=STORAGE_ACCOUNTCONNECTION_STRING::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.storageAccountConnectionString.value')"
          echo "::set-output name=STORAGE_ACCOUNT_NAME::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.storageAccountName.value')"
          echo "::set-output name=STORAGE_CONTAINER_NAME::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.storageContainerName.value')"
          echo "::set-output name=FUNCTIONS_APP_NAME::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.functionsAppName.value')"
          echo "::set-output name=FUNCTIONS_APP_URI::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.functionsAppUri.value')"
          echo "::set-output name=KEY_VAULT_NAME::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.keyVaultName.value')"
          #echo "::set-output name=FUNCTIONS_APP_KEY::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.functionsAppKey.value')"
          echo "::set-output name=RUN_SETTINGS::$(echo $DEPLOYMENTOUTPUT | jq --raw-output '.runSettings.value')"

          echo "========================================================================================================================================================================================================"
    
    
    
    # Runs a set of commands using the runners shell
    - name: Show create environment outputs
      run: |
        echo "ENVIRONMENT_INSTANCE_NAME:                ${{ steps.create-devtest-labs-environment.outputs.ENVIRONMENT_INSTANCE_NAME }}"
        echo "ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME: ${{ steps.create-devtest-labs-environment.outputs.ENVIRONMENT_INSTANCE_RESOURCE_GROUP_NAME }}"
        echo "FUNCTIONS_APP_NAME:                       ${{ steps.create-devtest-labs-environment.outputs.FUNCTIONS_APP_NAME }}"
        echo "FUNCTIONS_APP_URI:                        ${{ steps.create-devtest-labs-environment.outputs.FUNCTIONS_APP_URI }}"
        echo "STORAGE_ACCOUNT_NAME:                     ${{ steps.create-devtest-labs-environment.outputs.STORAGE_ACCOUNT_NAME }}"
        echo "STORAGE_CONTAINER_NAME:                   ${{ steps.create-devtest-labs-environment.outputs.STORAGE_CONTAINER_NAME }}"
        echo "KEY_VAULT_NAME:                           ${{ steps.create-devtest-labs-environment.outputs.KEY_VAULT_NAME }}"
        echo 'RUN_SETTINGS:                             ${{ steps.create-devtest-labs-environment.outputs.RUN_SETTINGS }}'
    
    
    # Write the runsettings output from the ARM script into a file so that the integration tests can use it
    - name: Write the DevTest Labs output runsettings to file
      run: |    
        echo '${{ steps.create-devtest-labs-environment.outputs.RUN_SETTINGS }}' > ${{ env.RUN_SETTINGS_FILENAME }}

   
     # Install AZCopy and copy sample files into the data lake
    - name: Install azcopy
      uses: kheiakiyama/install-azcopy-action@v1.0.3
      with:
        version: 'v10'
        creds: '${{ secrets.AZURE_DEV_TEST_LABS_CREDENTIALS }}'

    - name: Copy files to Azure Data Lake using AZCopy
      run: |

        STORAGE_ACCOUNT_NAME="${{ steps.create-devtest-labs-environment.outputs.STORAGE_ACCOUNT_NAME }}"
        STORAGE_CONTAINER_NAME="${{ steps.create-devtest-labs-environment.outputs.STORAGE_CONTAINER_NAME }}"
        # The exclude patter for the .keepDirectory files is not working, so workaround below if to find these files and remove them from ADLS
        azcopy copy "./DataPipelineTools.Functions.Tests/TestData" "https://$STORAGE_ACCOUNT_NAME.dfs.core.windows.net/$STORAGE_CONTAINER_NAME" --recursive=true --exclude-pattern=".keepDirectory"

        # Remove the .keepDirectory files, these are just used to allow us to add empty folders into the sample data in Git
        # See here for more info: https://github.com/Azure/azure-storage-azcopy/issues/796
        find ./DataPipelineTools.Functions.Tests/TestData -type f -name ".keepFolder"|while IFS=/ read FILENAME; do
          RELATIVE_PATH=$(echo "$FILENAME" | sed -r 's/\.\/DataPipelineTools\.Functions\.Tests\///g')
          azcopy rm "https://$STORAGE_ACCOUNT_NAME.dfs.core.windows.net/$STORAGE_CONTAINER_NAME/$RELATIVE_PATH"
        done

    
    - name: 'Deploy Azure Functions to Lab Environment using RBAC'
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ steps.create-devtest-labs-environment.outputs.FUNCTIONS_APP_NAME }}
        package: './${{ env.FUNCTIONS_PROJECT_NAME }}/bin/${{ env.BUILD_CONFIGURATION }}'


    - name: Run Integration Tests
      run: dotnet test --no-build --configuration ${{ env.BUILD_CONFIGURATION }} --filter TestCategory=IntegrationTest --output ./output --verbosity normal --settings ${{ env.RUN_SETTINGS_FILENAME }}



    
